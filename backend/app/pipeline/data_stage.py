from typing import Dict, List, Tuple

from app.pipeline.stage import PipelineStage
from app.ir.validation import ValidationResult
from app.ir.data_ir import DataIR, DataStore, DataAccess, canonical_datastore_name, deduplicate_datastores


# -------------------------
# Responsibility â†’ Data Rules
# -------------------------

def infer_datastore_access(responsibility_name: str) -> Dict[str, str]:
    """
    Infer datastore access from responsibility semantics.
    Returns: { datastore_name: access_type }
    """
    name = (responsibility_name or "").lower()
    access: Dict[str, str] = {}

    if "order" in name:
        access["Order"] = "read_write"

    if "payment" in name or "transaction" in name:
        access["Payment"] = "read_write"

    if any(k in name for k in ["user", "identity", "credential", "session"]):
        access["User"] = "read_write"

    # Validation responsibilities are usually read-only
    if "validate" in name or "verification" in name:
        for k in list(access.keys()):
            access[k] = "read"

    return access


# -------------------------
# Data Stage (Hardened)
# -------------------------

class DataStage(PipelineStage):
    name = "data"

    def run(self, context) -> ValidationResult:
        # If no services we can't infer anything
        if not context.service_ir:
            return ValidationResult.success()

        # canonical_name -> DataStore
        # Start fresh - don't merge from existing data_ir to avoid duplicates
        datastore_map: Dict[str, DataStore] = {}
        access_patterns: List[DataAccess] = []

        # -------------------------
        # 1) Discover datastores (service names + requirements + responsibilities)
        #    Build a canonical datastore map only once.
        # -------------------------
        for service in context.service_ir.services:
            seeds: List[str] = []

            # baseline inference from service name + requirements text
            seeds.extend(self._infer_possible_datastores(service.name, context.requirements_text))

            # also consider responsibilities (if present) to discover missing stores
            responsibilities = context.responsibility_map.get(service.id)
            if responsibilities:
                for resp in responsibilities.responsibilities:
                    # infer_datastore_access returns map of datastore -> access_type,
                    # but keys are what we need as potential datastores.
                    seeds.extend(infer_datastore_access(resp.name).keys())

            # create canonical datastores (id generated by DataStore/ BaseIR)
            for raw_name in seeds:
                canonical = canonical_datastore_name(raw_name)
                if not canonical:
                    continue
                if canonical not in datastore_map:
                    datastore_map[canonical] = DataStore(
                        name=canonical,
                        store_type="sql",
                    )

        # -------------------------
        # 2) Build deduplicated service->datastore access edges
        #    service_access[(service_name, canonical_datastore)] = access_type
        #    promote read -> read_write where appropriate
        # -------------------------
        service_access: Dict[Tuple[str, str], str] = {}

        for service in context.service_ir.services:
            responsibilities = context.responsibility_map.get(service.id)
            if not responsibilities:
                continue

            for resp in responsibilities.responsibilities:
                inferred = infer_datastore_access(resp.name)
                for raw_name, access_type in inferred.items():
                    canonical = canonical_datastore_name(raw_name)
                    if not canonical:
                        continue

                    # we only wire to datastores that we created/discovered in step 1
                    if canonical not in datastore_map:
                        # structural safety: skip unknown datastore
                        continue

                    key = (service.name, canonical)
                    existing = service_access.get(key)

                    # Promote access: read < read_write
                    if existing == "read_write":
                        continue
                    if existing == "read" and access_type == "read_write":
                        service_access[key] = "read_write"
                    elif not existing:
                        service_access[key] = access_type

        # Materialize deduped access patterns
        for (service_name, datastore_name), access_type in service_access.items():
            access_patterns.append(
                DataAccess(
                    service_id=service_name,
                    datastore_id=datastore_map[datastore_name].id,
                    access_type=access_type,
                )
            )

        # -------------------------
        # 3) Finalize Data IR
        # -------------------------

        # Get all datastores from the map
        all_datastores = list(datastore_map.values())
        
        # Deduplicate BEFORE creating DataIR
        final_datastores, final_access_patterns = deduplicate_datastores(
            all_datastores, access_patterns
        )

        # Ensure unique access patterns by (service_id, datastore_id)
        seen_edges = set()
        unique_access_patterns: List[DataAccess] = []
        for a in final_access_patterns:
            key = (a.service_id, a.datastore_id)
            if key in seen_edges:
                continue
            seen_edges.add(key)
            unique_access_patterns.append(a)

        context.data_ir = DataIR(
            datastores=final_datastores,
            access_patterns=unique_access_patterns,
        )

        return ValidationResult.success()

    # -------------------------
    # Baseline Datastore Inference
    # -------------------------
    def _infer_possible_datastores(self, service_name: str, text: str) -> List[str]:
        combined = f"{service_name or ''} {text or ''}".lower()
        stores: List[str] = []

        if "order" in combined:
            stores.append("Order")

        if "payment" in combined:
            stores.append("Payment")

        if any(k in combined for k in ["user", "customer", "identity"]):
            stores.append("User")

        return stores
